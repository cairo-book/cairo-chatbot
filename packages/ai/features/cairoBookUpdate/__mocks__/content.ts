export const mockedPages = [
  {
    name: "Generic Data Types",
    content:
      "# Generic Data Types\n\nWe use generics to create definitions for item declarations, such as structs and functions, which we can then use with many different concrete data types. In Cairo, we can use generics when defining functions, structs, enums, traits, implementations and methods. In this chapter, we are going to take a look at how to effectively use generic types with all of them.\n\nGenerics allow us to write reusable code that works with many types, thus avoiding code duplication. while enhancing code maintainability.\n\n## Generic Functions\n\nMaking a function generic means it can operate on different types, avoiding the need for multiple, type-specific implementations. This leads to significant code reduction and increases the flexibility of the code.\n\nWhen defining a function that uses generics, we place the generics in the function signature, where we would usually specify the data types of the parameter and return value. For example, imagine we want to create a function which given two `Array` of items, will return the largest one. If we need to perform this operation for lists of different types, then we would have to redefine the function each time. Luckily we can implement the function once using generics and move on to other tasks.\n\n```rust\n// Specify generic type T between the angulars\nfn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n    if l1.len() > l2.len() {\n        l1\n    } else {\n        l2\n    }\n}\n\nfn main() {\n    let mut l1 = array![1, 2];\n    let mut l2 = array![3, 4, 5];\n\n    // There is no need to specify the concrete type of T because\n    // it is inferred by the compiler\n    let l3 = largest_list(l1, l2);\n}\n```\n\nThe `largest_list` function compares two lists of the same type and returns the one with more elements and drops the other. If you compile the previous code, you will notice that it will fail with an error saying that there are no traits defined for dropping an array of a generic type. This happens because the compiler has no way to guarantee that an `Array<T>` is droppable when executing the `main` function. In order to drop an array of `T`, the compiler must first know how to drop `T`. This can be fixed by specifying in the function signature of `largest_list` that `T` must implement the drop trait. The correct function definition of `largest_list` is as follows:\n\n```rust\nfn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> Array<T> {\n    if l1.len() > l2.len() {\n        l1\n    } else {\n        l2\n    }\n}\n```\n\nThe new `largest_list` function includes in its definition the requirement that whatever generic type is placed there, it must be droppable. The `main` function remains unchanged, the compiler is smart enough to deduce which concrete type is being used and if it implements the `Drop` trait.\n\n### Constraints for Generic Types\n\nWhen defining generic types, it is useful to have information about them. Knowing which traits a generic type implements allows us to use it more effectively in a function's logic at the cost of constraining the generic types that can be used with the function. We saw an example of this previously by adding the `TDrop` implementation as part of the generic arguments of `largest_list`. While `TDrop` was added to satisfy the compiler's requirements, we can also add constraints to benefit our function logic.\n\nImagine that we want, given a list of elements of some generic type `T`, to find the smallest element among them. Initially, we know that for an element of type `T` to be comparable, it must implement the `PartialOrd` trait. The resulting function would be:\n\n```rust\n// Given a list of T get the smallest one\n// The PartialOrd trait implements comparison operations for T\nfn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> T {\n    // This represents the smallest element through the iteration\n    // Notice that we use the desnap (*) operator\n    let mut smallest = *list[0];\n\n    // The index we will use to move through the list\n    let mut index = 1;\n\n    // Iterate through the whole list storing the smallest\n    loop {\n        if index >= list.len() {\n            break smallest;\n        }\n        if *list[index] < smallest {\n            smallest = *list[index];\n        }\n        index = index + 1;\n    }\n}\n\nfn main() {\n    let list: Array<u8> = array![5, 3, 10];\n\n    // We need to specify that we are passing a snapshot of `list` as an argument\n    let s = smallest_element(@list);\n    assert!(s == 3);\n}\n```\n\nThe `smallest_element` function uses a generic type `T` that implements the `PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and returns a copy of the smallest element. Because the parameter is of type `@Array<T>`, we no longer need to drop it at the end of the execution and so we are not required to implement the `Drop` trait for `T` as well. Why it does not compile then?\n\nWhen indexing on `list`, the value results in a snap of the indexed element, unless `PartialOrd` is implemented for `@T` we need to desnap the element using `*`. The `*` operation requires a copy from `@T` to `T`, which means that `T` needs to implement the `Copy` trait. After copying an element of type `@T` to `T`, there are now variables with type `T` that need to be dropped, requiring `T` to implement the `Drop` trait as well. We must then add both `Drop` and `Copy` traits implementation for the function to be correct. After updating the `smallest_element` function the resulting code would be:\n\n```rust\nfn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: Copy<T>, impl TDrop: Drop<T>>(\n    list: @Array<T>\n) -> T {\n    let mut smallest = *list[0];\n    let mut index = 1;\n    loop {\n        if index >= list.len() {\n            break smallest;\n        }\n        if *list[index] < smallest {\n            smallest = *list[index];\n        }\n        index = index + 1;\n    }\n}\n```\n\n### Anonymous Generic Implementation Parameter (`+` operator)\n\nUntil now, we have always specified a name for each implementation of the required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for `Drop<T>`, and `TCopy` for `Copy<T>`.\n\nHowever, most of the time, we don't use the implementation in the function body; we only use it as a constraint. In these cases, we can use the `+` operator to specify that the generic type must implement a trait without naming the implementation. This is referred to as an _anonymous generic implementation parameter_.\n\nFor example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: PartialOrd<T>`.\n\nWe can rewrite the `smallest_element` function signature as follows:\n\n```rust\nfn smallest_element<T, +PartialOrd<T>, +Copy<T>, +Drop<T>>(list: @Array<T>) -> T {\n#     let mut smallest = *list[0];\n#     let mut index = 1;\n#     loop {\n#         if index >= list.len() {\n#             break smallest;\n#         }\n#         if *list[index] < smallest {\n#             smallest = *list[index];\n#         }\n#         index = index + 1;\n#     }\n# }\n```\n\n## Structs\n\nWe can also define structs to use a generic type parameter for one or more fields using the `<>` syntax, similar to function definitions. First, we declare the name of the type parameter inside the angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types. The next code example shows the definition `Wallet<T>` which has a `balance` field of type `T`.\n\n```rust\n#[derive(Drop)]\nstruct Wallet<T> {\n    balance: T\n}\n\nfn main() {\n    let w = Wallet { balance: 3 };\n}\n```\n\nThe above code derives the `Drop` trait for the `Wallet` type automatically. It is equivalent to writing the following code:\n\n```rust\nstruct Wallet<T> {\n    balance: T\n}\n\nimpl WalletDrop<T, +Drop<T>> of Drop<Wallet<T>>;\n\nfn main() {\n    let w = Wallet { balance: 3 };\n}\n```\n\nWe avoid using the `derive` macro for `Drop` implementation of `Wallet` and instead define our own `WalletDrop` implementation. Notice that we must define, just like functions, an additional generic type for `WalletDrop` saying that `T` implements the `Drop` trait as well. We are basically saying that the struct `Wallet<T>` is droppable as long as `T` is also droppable.\n\nFinally, if we want to add a field to `Wallet` representing its address and we want that field to be different than `T` but generic as well, we can simply add another generic type between the `<>`:\n\n```rust\n#[derive(Drop)]\nstruct Wallet<T, U> {\n    balance: T,\n    address: U,\n}\n\nfn main() {\n    let w = Wallet { balance: 3, address: 14 };\n}\n```\n\nWe add to `Wallet` struct definition a new generic type `U` and then assign this type to the new field member `address`. Notice that the derive attribute for the `Drop` trait works for `U` as well.\n\n## Enums\n\nAs we did with structs, we can define enums to hold generic data types in their variants. For example the `Option<T>` enum provided by the Cairo core library:\n\n```rust,noplayground\nenum Option<T> {\n    Some: T,\n    None,\n}\n```\n\nThe `Option<T>` enum is generic over a type `T` and has two variants: `Some`, which holds one value of type `T` and `None` that doesn't hold any value. By using the `Option<T>` enum, it is possible for us to express the abstract concept of an optional value and because the value has a generic type `T` we can use this abstraction with any type.\n\nEnums can use multiple generic types as well, like the definition of the `Result<T, E>` enum that the core library provides:\n\n```rust,noplayground\nenum Result<T, E> {\n    Ok: T,\n    Err: E,\n}\n```\n\nThe `Result<T, E>` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type `T` and `Err` which holds the value of type `E`. This definition makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a value of type `E`).\n\n## Generic Methods\n\nWe can implement methods on structs and enums, and use the generic types in their definition, too. Using our previous definition of `Wallet<T>` struct, we define a `balance` method for it:\n\n```rust\n#[derive(Copy, Drop)]\nstruct Wallet<T> {\n    balance: T\n}\n\ntrait WalletTrait<T> {\n    fn balance(self: @Wallet<T>) -> T;\n}\n\nimpl WalletImpl<T, +Copy<T>> of WalletTrait<T> {\n    fn balance(self: @Wallet<T>) -> T {\n        return *self.balance;\n    }\n}\n\nfn main() {\n    let w = Wallet { balance: 50 };\n    assert!(w.balance() == 50);\n}\n```\n\nWe first define `WalletTrait<T>` trait using a generic type `T` which defines a method that returns the value of the field `balance` from `Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. Note that you need to include a generic type in both definitions of the trait and the implementation.\n\nWe can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only for `Wallet<u128>` instances rather than `Wallet<T>`. In the code example, we define an implementation for wallets which have a concrete type of `u128` for the `balance` field.\n\n```rust\n#[derive(Copy, Drop)]\nstruct Wallet<T> {\n    balance: T\n}\n\n/// Generic trait for wallets\ntrait WalletTrait<T> {\n    fn balance(self: @Wallet<T>) -> T;\n}\n\nimpl WalletImpl<T, +Copy<T>> of WalletTrait<T> {\n    fn balance(self: @Wallet<T>) -> T {\n        return *self.balance;\n    }\n}\n\n/// Trait for wallets of type u128\ntrait WalletReceiveTrait {\n    fn receive(ref self: Wallet<u128>, value: u128);\n}\n\nimpl WalletReceiveImpl of WalletReceiveTrait {\n    fn receive(ref self: Wallet<u128>, value: u128) {\n        self.balance += value;\n    }\n}\n\nfn main() {\n    let mut w = Wallet { balance: 50 };\n    assert!(w.balance() == 50);\n\n    w.receive(100);\n    assert!(w.balance() == 150);\n}\n```\n\nThe new method `receive` increments the size of the balance of any instance of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a mutable variable in order for it to be able to update its balance. If we were to change the initialization of `w` by changing the type of `balance` the previous code wouldn't compile.\n\nCairo allows us to define generic methods inside generic traits as well. Using the past implementation from `Wallet<U, V>` we are going to define a trait that picks two wallets of different generic types and creates a new one with a generic type of each. First, let's rewrite the struct definition:\n\n```rust,noplayground\nstruct Wallet<T, U> {\n    balance: T,\n    address: U,\n}\n```\n\nNext, we are going to naively define the mixup trait and implementation:\n\n```rust,noplayground\n// This does not compile!\ntrait WalletMixTrait<T1, U1> {\n    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2>;\n}\n\nimpl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> {\n        Wallet { balance: self.balance, address: other.address }\n    }\n}\n\n```\n\nWe are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` method which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` creates a new `Wallet<T1, U2>`. As `mixup` signature specifies, both `self` and `other` are getting dropped at the end of the function, which is why this code does not compile. If you have been following from the start until now you would know that we must add a requirement for all the generic types specifying that they will implement the `Drop` trait for the compiler to know how to drop instances of `Wallet<T, U>`. The updated implementation is as follows:\n\n```rust\ntrait WalletMixTrait<T1, U1> {\n    fn mixup<T2, +Drop<T2>, U2, +Drop<U2>>(\n        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n    ) -> Wallet<T1, U2>;\n}\n\nimpl WalletMixImpl<T1, +Drop<T1>, U1, +Drop<U1>> of WalletMixTrait<T1, U1> {\n    fn mixup<T2, +Drop<T2>, U2, +Drop<U2>>(\n        self: Wallet<T1, U1>, other: Wallet<T2, U2>\n    ) -> Wallet<T1, U2> {\n        Wallet { balance: self.balance, address: other.address }\n    }\n}\n```\n\nWe add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` declaration. Then we do the same for `T2` and `U2`, this time as part of `mixup` signature. We can now try the `mixup` function:\n\n```rust,noplayground\nfn main() {\n    let w1: Wallet<bool, u128> = Wallet { balance: true, address: 10 };\n    let w2: Wallet<felt252, u8> = Wallet { balance: 32, address: 100 };\n\n    let w3 = w1.mixup(w2);\n\n    assert!(w3.balance);\n    assert!(w3.address == 100);\n}\n```\n\nWe first create two instances: one of `Wallet<bool, u128>` and the other of `Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, u8>` instance.\n",
  },
];
